#include "ros_weaver/core/launch_file_generator.hpp"
#include "ros_weaver/core/project.hpp"

#include <QTextStream>
#include <QRegularExpression>

namespace ros_weaver {

LaunchFileGenerator::LaunchFileGenerator(QObject* parent)
  : QObject(parent)
{
}

LaunchFileGenerator::~LaunchFileGenerator() = default;

QString LaunchFileGenerator::generate(const Project& project,
                                       const LaunchGeneratorOptions& options) {
  QList<LaunchNodeConfig> nodes = extractNodeConfigs(project, options);
  return generate(nodes, options);
}

QString LaunchFileGenerator::generate(const QList<LaunchNodeConfig>& nodes,
                                       const LaunchGeneratorOptions& options) {
  emit generationProgress(0, "Starting launch file generation...");

  QString content;
  switch (options.format) {
    case LaunchFormat::Python:
      content = generatePython(nodes, options);
      break;
    case LaunchFormat::XML:
      content = generateXML(nodes, options);
      break;
  }

  emit generationProgress(100, "Launch file generation complete");
  return content;
}

QList<LaunchNodeConfig> LaunchFileGenerator::extractNodeConfigs(
    const Project& project, const LaunchGeneratorOptions& options) {

  QList<LaunchNodeConfig> nodes;

  // Build remapping map
  QMap<QUuid, QList<QPair<QString, QString>>> remappings;
  buildRemappings(project, remappings);

  // Build block map for quick lookup
  QMap<QUuid, const BlockData*> blockMap;
  for (const BlockData& block : project.blocks()) {
    blockMap[block.id] = &block;
  }

  // Create node configs from blocks
  for (const BlockData& block : project.blocks()) {
    LaunchNodeConfig config;
    config.name = toSnakeCase(block.name);
    config.packageName = options.packageName;
    config.executableName = config.name + "_node";

    // Apply global namespace if set
    if (!options.namespace_.isEmpty()) {
      config.namespace_ = options.namespace_;
    }

    // Extract parameters from block
    for (const BlockParamData& param : block.parameters) {
      config.parameters[param.name] = param.currentValue.isNull() ?
                                       param.defaultValue : param.currentValue;
    }

    // Apply remappings
    if (remappings.contains(block.id)) {
      config.remappings = remappings[block.id];
    }

    // Check if this should be a composable node
    config.useComposition = options.generateComposableContainer;
    if (config.useComposition) {
      config.composableContainer = options.containerName;
    }

    nodes.append(config);
  }

  return nodes;
}

QString LaunchFileGenerator::fileExtension(LaunchFormat format) {
  switch (format) {
    case LaunchFormat::Python: return ".launch.py";
    case LaunchFormat::XML: return ".launch.xml";
  }
  return ".launch";
}

void LaunchFileGenerator::buildRemappings(
    const Project& project,
    QMap<QUuid, QList<QPair<QString, QString>>>& remappings) {

  // Build block map
  QMap<QUuid, const BlockData*> blockMap;
  for (const BlockData& block : project.blocks()) {
    blockMap[block.id] = &block;
  }

  // Process connections to create remappings
  for (const ConnectionData& conn : project.connections()) {
    const BlockData* sourceBlock = blockMap.value(conn.sourceBlockId);
    const BlockData* targetBlock = blockMap.value(conn.targetBlockId);

    if (!sourceBlock || !targetBlock) continue;
    if (conn.sourcePinIndex >= sourceBlock->outputPins.size()) continue;
    if (conn.targetPinIndex >= targetBlock->inputPins.size()) continue;

    QString sourceTopic = sourceBlock->outputPins[conn.sourcePinIndex].name;
    QString targetTopic = targetBlock->inputPins[conn.targetPinIndex].name;

    // If topics differ, remap subscriber to match publisher
    if (sourceTopic != targetTopic) {
      remappings[conn.targetBlockId].append(qMakePair(targetTopic, sourceTopic));
    }
  }
}

// Python format generation

QString LaunchFileGenerator::generatePython(const QList<LaunchNodeConfig>& nodes,
                                             const LaunchGeneratorOptions& options) {
  QString content;
  QTextStream stream(&content);

  // Imports
  stream << "\"\"\"" << (options.description.isEmpty() ?
              "Launch file generated by ROS Weaver" : options.description) << "\"\"\"\n\n";

  stream << "from launch import LaunchDescription\n";
  stream << "from launch_ros.actions import Node\n";

  if (options.generateComposableContainer) {
    stream << "from launch_ros.actions import ComposableNodeContainer\n";
    stream << "from launch_ros.descriptions import ComposableNode\n";
  }

  stream << "from launch.actions import DeclareLaunchArgument\n";
  stream << "from launch.substitutions import LaunchConfiguration\n";

  if (options.includeParamsFile) {
    stream << "from ament_index_python.packages import get_package_share_directory\n";
    stream << "import os\n";
  }

  stream << "\n\n";
  stream << "def generate_launch_description():\n";

  int ind = 4;

  // Package directory for params
  if (options.includeParamsFile) {
    stream << indent(ind) << "# Get the package share directory\n";
    stream << indent(ind) << "pkg_dir = get_package_share_directory('" << options.packageName << "')\n";
    stream << indent(ind) << "params_file = os.path.join(pkg_dir, '" << options.paramsFilePath << "')\n\n";
  }

  // Launch arguments
  if (options.generateArguments) {
    stream << indent(ind) << "# Declare launch arguments\n";
    stream << indent(ind) << "use_sim_time_arg = DeclareLaunchArgument(\n";
    stream << indent(ind + 4) << "'use_sim_time',\n";
    stream << indent(ind + 4) << "default_value='" << (options.useSimTime ? "true" : "false") << "',\n";
    stream << indent(ind + 4) << "description='Use simulation time')\n\n";

    if (!options.namespace_.isEmpty()) {
      stream << indent(ind) << "namespace_arg = DeclareLaunchArgument(\n";
      stream << indent(ind + 4) << "'namespace',\n";
      stream << indent(ind + 4) << "default_value='" << options.namespace_ << "',\n";
      stream << indent(ind + 4) << "description='Top-level namespace')\n\n";
    }
  }

  // Generate composable container if needed
  if (options.generateComposableContainer) {
    stream << indent(ind) << "# Composable node container\n";
    stream << indent(ind) << "container = ComposableNodeContainer(\n";
    stream << indent(ind + 4) << "name='" << options.containerName << "',\n";
    stream << indent(ind + 4) << "namespace='',\n";
    stream << indent(ind + 4) << "package='rclcpp_components',\n";
    stream << indent(ind + 4) << "executable='component_container',\n";
    stream << indent(ind + 4) << "composable_node_descriptions=[\n";

    for (int i = 0; i < nodes.size(); ++i) {
      stream << generatePythonComposableNode(nodes[i], ind + 8);
      if (i < nodes.size() - 1) {
        stream << ",";
      }
      stream << "\n";
    }

    stream << indent(ind + 4) << "],\n";
    stream << indent(ind + 4) << "output='screen',\n";
    stream << indent(ind) << ")\n\n";

    // Return launch description
    stream << indent(ind) << "return LaunchDescription([\n";
    if (options.generateArguments) {
      stream << indent(ind + 4) << "use_sim_time_arg,\n";
      if (!options.namespace_.isEmpty()) {
        stream << indent(ind + 4) << "namespace_arg,\n";
      }
    }
    stream << indent(ind + 4) << "container,\n";
    stream << indent(ind) << "])\n";
  } else {
    // Generate individual nodes
    stream << indent(ind) << "# Node definitions\n";

    for (int i = 0; i < nodes.size(); ++i) {
      const LaunchNodeConfig& node = nodes[i];
      stream << indent(ind) << node.name << "_node = " << generatePythonNode(node, ind);
      stream << "\n\n";
    }

    // Return launch description
    stream << indent(ind) << "return LaunchDescription([\n";
    if (options.generateArguments) {
      stream << indent(ind + 4) << "use_sim_time_arg,\n";
      if (!options.namespace_.isEmpty()) {
        stream << indent(ind + 4) << "namespace_arg,\n";
      }
    }
    for (const LaunchNodeConfig& node : nodes) {
      stream << indent(ind + 4) << node.name << "_node,\n";
    }
    stream << indent(ind) << "])\n";
  }

  return content;
}

QString LaunchFileGenerator::generatePythonNode(const LaunchNodeConfig& node, int ind) {
  QString content;
  QTextStream stream(&content);

  stream << "Node(\n";
  stream << indent(ind + 4) << "package='" << node.packageName << "',\n";
  stream << indent(ind + 4) << "executable='" << node.executableName << "',\n";
  stream << indent(ind + 4) << "name='" << node.name << "',\n";

  if (!node.namespace_.isEmpty()) {
    stream << indent(ind + 4) << "namespace=LaunchConfiguration('namespace'),\n";
  }

  // Parameters
  stream << indent(ind + 4) << "parameters=[";
  if (!node.parameters.isEmpty()) {
    stream << "params_file, ";
  }
  stream << "{'use_sim_time': LaunchConfiguration('use_sim_time')}],\n";

  // Remappings
  if (!node.remappings.isEmpty()) {
    stream << indent(ind + 4) << "remappings=[\n";
    for (int i = 0; i < node.remappings.size(); ++i) {
      const auto& remap = node.remappings[i];
      stream << indent(ind + 8) << "('" << remap.first << "', '" << remap.second << "')";
      if (i < node.remappings.size() - 1) {
        stream << ",";
      }
      stream << "\n";
    }
    stream << indent(ind + 4) << "],\n";
  }

  // Respawn
  if (node.respawn) {
    stream << indent(ind + 4) << "respawn=True,\n";
    stream << indent(ind + 4) << "respawn_delay=" << node.respawnDelay << ",\n";
  }

  // Arguments
  if (!node.arguments.isEmpty()) {
    stream << indent(ind + 4) << "arguments=[";
    for (int i = 0; i < node.arguments.size(); ++i) {
      stream << "'" << node.arguments[i] << "'";
      if (i < node.arguments.size() - 1) {
        stream << ", ";
      }
    }
    stream << "],\n";
  }

  stream << indent(ind + 4) << "output='" << node.output << "',\n";
  stream << indent(ind) << ")";

  return content;
}

QString LaunchFileGenerator::generatePythonComposableNode(const LaunchNodeConfig& node, int ind) {
  QString content;
  QTextStream stream(&content);

  stream << indent(ind) << "ComposableNode(\n";
  stream << indent(ind + 4) << "package='" << node.packageName << "',\n";
  stream << indent(ind + 4) << "plugin='" << node.packageName << "::" << node.name << "',\n";
  stream << indent(ind + 4) << "name='" << node.name << "',\n";

  if (!node.namespace_.isEmpty()) {
    stream << indent(ind + 4) << "namespace='" << node.namespace_ << "',\n";
  }

  // Parameters
  if (!node.parameters.isEmpty()) {
    stream << indent(ind + 4) << "parameters=[params_file],\n";
  }

  // Remappings
  if (!node.remappings.isEmpty()) {
    stream << indent(ind + 4) << "remappings=[\n";
    for (int i = 0; i < node.remappings.size(); ++i) {
      const auto& remap = node.remappings[i];
      stream << indent(ind + 8) << "('" << remap.first << "', '" << remap.second << "')";
      if (i < node.remappings.size() - 1) {
        stream << ",";
      }
      stream << "\n";
    }
    stream << indent(ind + 4) << "],\n";
  }

  stream << indent(ind) << ")";

  return content;
}

QString LaunchFileGenerator::generatePythonContainer(const QString& containerName, int ind) {
  Q_UNUSED(containerName)
  Q_UNUSED(ind)
  return QString();  // Handled inline in generatePython
}

// XML format generation

QString LaunchFileGenerator::generateXML(const QList<LaunchNodeConfig>& nodes,
                                          const LaunchGeneratorOptions& options) {
  QString content;
  QTextStream stream(&content);

  stream << "<?xml version=\"1.0\"?>\n";
  stream << "<!-- " << (options.description.isEmpty() ?
              "Launch file generated by ROS Weaver" : escapeXml(options.description)) << " -->\n";
  stream << "<launch>\n";

  int ind = 2;

  // Arguments
  if (options.generateArguments) {
    stream << indent(ind) << "<!-- Launch arguments -->\n";
    stream << indent(ind) << "<arg name=\"use_sim_time\" default=\""
           << (options.useSimTime ? "true" : "false") << "\"/>\n";

    if (!options.namespace_.isEmpty()) {
      stream << indent(ind) << "<arg name=\"namespace\" default=\""
             << escapeXml(options.namespace_) << "\"/>\n";
    }
    stream << "\n";
  }

  // Parameters file path
  if (options.includeParamsFile) {
    stream << indent(ind) << "<!-- Parameters file -->\n";
    stream << indent(ind) << "<let name=\"params_file\" value=\"$(find-pkg-share "
           << options.packageName << ")/" << options.paramsFilePath << "\"/>\n\n";
  }

  // Generate composable container or individual nodes
  if (options.generateComposableContainer) {
    stream << indent(ind) << "<!-- Composable node container -->\n";
    stream << indent(ind) << "<node_container pkg=\"rclcpp_components\" exec=\"component_container\"\n";
    stream << indent(ind) << "                name=\"" << options.containerName << "\" namespace=\"\">\n";

    for (const LaunchNodeConfig& node : nodes) {
      stream << generateXMLComposableNode(node, ind + 2);
    }

    stream << indent(ind) << "</node_container>\n";
  } else {
    stream << indent(ind) << "<!-- Nodes -->\n";
    for (const LaunchNodeConfig& node : nodes) {
      stream << generateXMLNode(node, ind);
      stream << "\n";
    }
  }

  stream << "</launch>\n";

  return content;
}

QString LaunchFileGenerator::generateXMLNode(const LaunchNodeConfig& node, int ind) {
  QString content;
  QTextStream stream(&content);

  stream << indent(ind) << "<node pkg=\"" << escapeXml(node.packageName)
         << "\" exec=\"" << escapeXml(node.executableName)
         << "\" name=\"" << escapeXml(node.name) << "\"";

  if (!node.namespace_.isEmpty()) {
    stream << " namespace=\"$(var namespace)\"";
  }

  stream << " output=\"" << node.output << "\"";

  if (node.respawn) {
    stream << " respawn=\"true\" respawn_delay=\"" << node.respawnDelay << "\"";
  }

  // Check if we have children
  bool hasChildren = !node.parameters.isEmpty() || !node.remappings.isEmpty() ||
                     !node.arguments.isEmpty();

  if (!hasChildren) {
    stream << "/>\n";
    return content;
  }

  stream << ">\n";

  // Parameters
  stream << indent(ind + 2) << "<param from=\"$(var params_file)\"/>\n";
  stream << indent(ind + 2) << "<param name=\"use_sim_time\" value=\"$(var use_sim_time)\"/>\n";

  // Remappings
  for (const auto& remap : node.remappings) {
    stream << indent(ind + 2) << "<remap from=\"" << escapeXml(remap.first)
           << "\" to=\"" << escapeXml(remap.second) << "\"/>\n";
  }

  stream << indent(ind) << "</node>\n";

  return content;
}

QString LaunchFileGenerator::generateXMLComposableNode(const LaunchNodeConfig& node, int ind) {
  QString content;
  QTextStream stream(&content);

  stream << indent(ind) << "<composable_node pkg=\"" << escapeXml(node.packageName)
         << "\" plugin=\"" << escapeXml(node.packageName) << "::" << escapeXml(node.name)
         << "\" name=\"" << escapeXml(node.name) << "\"";

  if (!node.namespace_.isEmpty()) {
    stream << " namespace=\"" << escapeXml(node.namespace_) << "\"";
  }

  // Check if we have children
  bool hasChildren = !node.parameters.isEmpty() || !node.remappings.isEmpty();

  if (!hasChildren) {
    stream << "/>\n";
    return content;
  }

  stream << ">\n";

  // Parameters
  if (!node.parameters.isEmpty()) {
    stream << indent(ind + 2) << "<param from=\"$(var params_file)\"/>\n";
  }

  // Remappings
  for (const auto& remap : node.remappings) {
    stream << indent(ind + 2) << "<remap from=\"" << escapeXml(remap.first)
           << "\" to=\"" << escapeXml(remap.second) << "\"/>\n";
  }

  stream << indent(ind) << "</composable_node>\n";

  return content;
}

QString LaunchFileGenerator::generateXMLContainer(const QString& containerName, int ind) {
  Q_UNUSED(containerName)
  Q_UNUSED(ind)
  return QString();  // Handled inline in generateXML
}

// Helpers

QString LaunchFileGenerator::indent(int spaces) const {
  return QString(spaces, ' ');
}

QString LaunchFileGenerator::escapeXml(const QString& str) const {
  QString escaped = str;
  escaped.replace("&", "&amp;");
  escaped.replace("<", "&lt;");
  escaped.replace(">", "&gt;");
  escaped.replace("\"", "&quot;");
  escaped.replace("'", "&apos;");
  return escaped;
}

QString LaunchFileGenerator::formatPythonValue(const QVariant& value) const {
  switch (value.type()) {
    case QVariant::Bool:
      return value.toBool() ? "True" : "False";
    case QVariant::Int:
    case QVariant::LongLong:
      return QString::number(value.toLongLong());
    case QVariant::Double:
      return QString::number(value.toDouble());
    case QVariant::String:
      return QString("'%1'").arg(value.toString().replace("'", "\\'"));
    default:
      return QString("'%1'").arg(value.toString());
  }
}

QString LaunchFileGenerator::formatXmlValue(const QVariant& value) const {
  switch (value.type()) {
    case QVariant::Bool:
      return value.toBool() ? "true" : "false";
    default:
      return escapeXml(value.toString());
  }
}

QString LaunchFileGenerator::toSnakeCase(const QString& name) const {
  QString result;
  for (int i = 0; i < name.length(); ++i) {
    QChar c = name[i];
    if (c.isUpper()) {
      if (i > 0) {
        result += '_';
      }
      result += c.toLower();
    } else if (c == ' ' || c == '-') {
      result += '_';
    } else {
      result += c;
    }
  }
  return result;
}

}  // namespace ros_weaver
